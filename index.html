<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Memo Inscriber</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        h1 { color: #333; margin-bottom: 8px; font-size: 28px; }
        .subtitle { color: #666; margin-bottom: 24px; font-size: 14px; }
        .wallet-section {
            margin-bottom: 24px;
            padding: 16px;
            background: #f5f5f5;
            border-radius: 8px;
        }
        .wallet-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .wallet-address {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #666;
            word-break: break-all;
            display: none;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            width: 100%;
        }
        button:hover:not(:disabled) { background: #5568d3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .input-row { display: flex; gap: 16px; flex-wrap: wrap; }
        .input-section { margin-bottom: 24px; flex: 1 1 320px; }
        .panel { background: #f9f9f9; border: 1px solid #e5e5e5; border-radius: 12px; padding: 16px; }
        label { display: block; margin-bottom: 8px; color: #333; font-weight: 500; }
        textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        textarea:focus { outline: none; border-color: #667eea; }
        .char-count {
            text-align: right;
            font-size: 12px;
            color: #999;
            margin-top: 4px;
        }
        .char-count.warning { color: #ff6b6b; }
        .char-count.error { color: #dc3545; font-weight: 600; }
        .status {
            margin-top: 16px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; display: block; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; display: block; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; display: block; }
        .tx-link {
            margin-top: 8px;
            display: block;
            color: #667eea;
            text-decoration: none;
            word-break: break-all;
            font-size: 12px;
        }
        .tx-link:hover { text-decoration: underline; }
        .copy-btn {
            background: #e2e8f0;
            color: #4a5568;
            padding: 4px 10px;
            font-size: 12px;
            margin-left: 8px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            font-weight: 500;
        }
        .copy-btn:hover { background: #cbd5e0; }
        .protocol-warning {
            background: #fff3cd;
            color: #856404;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid #ffc107;
        }
        .protocol-warning strong { display: block; margin-bottom: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Solana Memo Inscriber</h1>
        <p class="subtitle">Write your message directly to the Solana blockchain (Gas fee only ~0.000005 SOL)</p>

        <div id="protocolWarning" class="protocol-warning" style="display: none;">
            <strong>‚ö†Ô∏è Local File Detected</strong>
            Browser extensions don't work with file:// protocol. Please run a local server:<br>
            <code>python -m http.server 8000</code> then visit <code>http://localhost:8000</code>
        </div>

        <div class="wallet-section">
            <div class="wallet-status">
                <div><strong>Wallet Status:</strong> <span id="walletStatus">Not Connected</span></div>
                <button id="connectBtn">Connect Wallet</button>
            </div>
            <div id="walletAddress" class="wallet-address"></div>
        </div>

        <div class="input-row">
            <div class="input-section panel">
                <label for="messageInput">Your Message (Max 500 characters, 560 bytes):</label>
                <textarea id="messageInput" placeholder="Type your message here..." maxlength="500"></textarea>
                <div id="charCount" class="char-count">0 / 500 characters (0 bytes)</div>
                <label style="display:flex;align-items:center;gap:8px;margin-top:8px;font-size:14px;color:#333;">
                    <input type="checkbox" id="priorityToggle" checked style="width:16px;height:16px;">
                    Use priority fee (50,000 ¬µLamports) for higher reliability
                </label>
                <button id="inscribeBtn" disabled style="margin-top:12px;">Inscribe to Blockchain</button>
            </div>
            <div class="input-section panel">
                <label for="txLookupInput">Lookup Memo by Transaction Signature:</label>
                <input id="txLookupInput" type="text" placeholder="Paste transaction signature" style="width:100%;padding:10px;border:2px solid #e0e0e0;border-radius:8px;font-size:14px;">
                <button id="lookupBtn" style="margin-top:12px;">Fetch Memo</button>
                <div id="lookupStatus" class="status" style="display:none;margin-top:12px;"></div>
            </div>
        </div>
        <div id="status" class="status"></div>
    </div>

    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <script>
        const MEMO_PROGRAM_ID = 'Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo';
        const MAX_BYTES = 560;
        const MAX_CHARS = 500;

        let wallet = null;
        let publicKey = null;
        let isConnected = false;

        // Check for file:// protocol
        if (window.location.protocol === 'file:') {
            document.getElementById('protocolWarning').style.display = 'block';
        }

        const connectBtn = document.getElementById('connectBtn');
        const inscribeBtn = document.getElementById('inscribeBtn');
        const messageInput = document.getElementById('messageInput');
        const walletStatus = document.getElementById('walletStatus');
        const walletAddress = document.getElementById('walletAddress');
        const charCount = document.getElementById('charCount');
        const status = document.getElementById('status');
        const priorityToggle = document.getElementById('priorityToggle');
        const txLookupInput = document.getElementById('txLookupInput');
        const lookupBtn = document.getElementById('lookupBtn');
        const lookupStatus = document.getElementById('lookupStatus');

        // Copy signature buttons (event delegation)
        document.addEventListener('click', (e) => {
            const btn = e.target.closest('.copy-btn');
            if (!btn) return;
            const sig = btn.getAttribute('data-sig');
            if (!sig) return;
            navigator.clipboard.writeText(sig).then(() => {
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
            }).catch(() => {
                btn.textContent = 'Copy failed';
                setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
            });
        });

        // Small base58 decoder (for memo data fallback)
        function decodeBase58(str) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            const base = alphabet.length;
            const bytes = [0];
            for (let i = 0; i < str.length; i++) {
                const c = alphabet.indexOf(str[i]);
                if (c < 0) throw new Error('Invalid base58 char');
                let carry = c;
                for (let j = 0; j < bytes.length; ++j) {
                    const val = bytes[j] * base + carry;
                    bytes[j] = val & 0xff;
                    carry = val >> 8;
                }
                while (carry > 0) {
                    bytes.push(carry & 0xff);
                    carry >>= 8;
                }
            }
            return new Uint8Array(bytes.reverse());
        }

        function showStatus(type, message) {
            status.className = `status ${type}`;
            status.textContent = message;
            status.style.display = 'block';
        }

        function getWallet() {
            return window.solana && (window.solana.isPhantom || typeof window.solana.connect === 'function') ? window.solana : null;
        }

        connectBtn.addEventListener('click', async () => {
            if (isConnected) {
                if (wallet && wallet.disconnect) await wallet.disconnect();
                walletStatus.textContent = 'Not Connected';
                walletAddress.style.display = 'none';
                connectBtn.textContent = 'Connect Wallet';
                inscribeBtn.disabled = true;
                publicKey = null;
                isConnected = false;
                return;
            }

            wallet = getWallet();
            if (!wallet) {
                showStatus('error', 'Phantom wallet not found. Make sure it\'s installed and the page is served via HTTP (not file://)');
                return;
            }

            try {
                showStatus('info', 'Connecting...');
                const response = await wallet.connect();
                publicKey = response.publicKey;
                walletStatus.textContent = 'Connected';
                walletAddress.textContent = `Address: ${publicKey.toString()}`;
                walletAddress.style.display = 'block';
                connectBtn.textContent = 'Disconnect';
                isConnected = true;
                
                // Enable inscribe button if message is valid
                const text = messageInput.value.trim();
                const bytes = new TextEncoder().encode(text).length;
                inscribeBtn.disabled = !text || bytes > MAX_BYTES;
                status.style.display = 'none';

                wallet.on('disconnect', () => {
                    walletStatus.textContent = 'Not Connected';
                    walletAddress.style.display = 'none';
                    connectBtn.textContent = 'Connect Wallet';
                    inscribeBtn.disabled = true;
                    publicKey = null;
                    isConnected = false;
                });
            } catch (err) {
                showStatus('error', 'Connection failed: ' + err.message);
            }
        });

        messageInput.addEventListener('input', () => {
            const text = messageInput.value;
            const bytes = new TextEncoder().encode(text).length;
            charCount.textContent = `${text.length} / ${MAX_CHARS} characters (${bytes} bytes)`;
            charCount.className = bytes > MAX_BYTES ? 'char-count error' : bytes > MAX_BYTES * 0.9 ? 'char-count warning' : 'char-count';
            
            // Enable inscribe button if wallet is connected and message is valid
            if (isConnected && text.trim() && bytes <= MAX_BYTES) {
                inscribeBtn.disabled = false;
            } else {
                inscribeBtn.disabled = !isConnected || !text.trim() || bytes > MAX_BYTES;
            }
        });

        inscribeBtn.addEventListener('click', async () => {
            // 1. Basic Validation
            const message = messageInput.value.trim();
            if (!message || !publicKey) return showStatus('error', 'Connect wallet & enter message');
            
            const messageBytes = new TextEncoder().encode(message);
            if (messageBytes.length > MAX_BYTES) return showStatus('error', 'Message too long');

            try {
                inscribeBtn.disabled = true;
                showStatus('info', '‚ö° Preparing High-Priority Transaction...');

                // RPC endpoints (try in order, no API keys required)
                const rpcEndpoints = [
                    'https://solana.drpc.org',
                    'https://solana.lavenderfive.com',
                    'https://public.rpc.solanavibestation.com',
                    'https://solana.leorpc.com/?api_key=FREE',
                    'https://solana.api.onfinality.io/public',
                    'https://solana.api.pocket.network',
                    'https://api.mainnet-beta.solana.com'
                ];
                
                // CORS proxy fallbacks
                const corsProxies = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url='
                ];

                let blockhash = null;
                let lastValidBlockHeight = null;
                let rpcUrl = rpcEndpoints[0];

                // Helper: try direct, then CORS proxies
                async function tryFetchRpc(endpoint, body) {
                    // Try direct first
                    try {
                        const resp = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(body)
                        });
                        if (resp.ok) {
                            const data = await resp.json();
                            if (data.result) return { data, url: endpoint };
                        }
                    } catch (e) {
                        console.warn('Direct failed:', endpoint, e.message);
                    }
                    
                    // Try CORS proxies
                    for (const proxy of corsProxies) {
                        try {
                            const proxyUrl = proxy + encodeURIComponent(endpoint);
                            const resp = await fetch(proxyUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(body)
                            });
                            if (resp.ok) {
                                const data = await resp.json();
                                if (data.result) {
                                    console.log('‚úÖ Via CORS proxy:', proxy);
                                    return { data, url: proxyUrl };
                                }
                            }
                        } catch (e) {
                            // try next proxy
                        }
                    }
                    return null;
                }

                // 2. Fetch Blockhash (commitment: confirmed)
                for (const endpoint of rpcEndpoints) {
                    const result = await tryFetchRpc(endpoint, {
                        jsonrpc: '2.0', id: 1, method: 'getLatestBlockhash', params: [{ commitment: 'confirmed' }]
                    });
                    
                    if (result?.data?.result?.value?.blockhash) {
                        blockhash = result.data.result.value.blockhash;
                        lastValidBlockHeight = result.data.result.value.lastValidBlockHeight;
                        rpcUrl = result.url;
                        console.log('‚úÖ Connected to:', endpoint);
                        break;
                    }
                }

                if (!blockhash) throw new Error('Could not fetch blockhash from any RPC endpoint.');

                showStatus('info', '‚úçÔ∏è SIGN NOW! (Blockhash expires in ~60s)');

                // 3. Build Transaction
                const transaction = new solanaWeb3.Transaction({
                    recentBlockhash: blockhash,
                    feePayer: publicKey
                });

                // A. High priority fee (optional)
                if (priorityToggle.checked) {
                    transaction.add(
                        solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({
                            microLamports: 50000
                        })
                    );
                }

                // B. Memo Instruction
                transaction.add(
                    new solanaWeb3.TransactionInstruction({
                        keys: [{ pubkey: publicKey, isSigner: true, isWritable: false }],
                        programId: new solanaWeb3.PublicKey('Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo'),
                        data: messageBytes
                    })
                );

                // 4. Sign & Send via wallet (skipPreflight=false for better errors)
                showStatus('info', '‚úçÔ∏è Please approve in wallet...');
                const signatureResp = await wallet.signAndSendTransaction(transaction, { skipPreflight: false });
                const sigString = typeof signatureResp === 'string' ? signatureResp : (signatureResp?.signature || signatureResp);

                console.log("üöÄ Broadcasted:", sigString);
                showStatus('info', 'Transaction sent! Verifying on-chain...');
                
                // 5. Confirm transaction on-chain via HTTP polling (no websockets)
                let verified = false;
                for (let attempt = 0; attempt < 15; attempt++) { // ~30s total
                    await new Promise(r => setTimeout(r, 2000));
                    try {
                        const statusResp = await fetch(rpcUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                id: 1,
                                method: 'getSignatureStatuses',
                                params: [[sigString], { searchTransactionHistory: true }]
                            })
                        });
                        const statusData = await statusResp.json();
                        const status = statusData.result?.value?.[0];
                        if (status && (status.confirmationStatus === 'confirmed' || status.confirmationStatus === 'finalized')) {
                            if (status.err) {
                                throw new Error('Transaction failed on-chain: ' + JSON.stringify(status.err));
                            }
                            verified = true;
                            break;
                        }
                    } catch (verifyErr) {
                        // ignore and keep polling
                    }
                }

                if (!verified) {
                    showStatus('info', 'Broadcasted. Final confirmation pending. Check Solscan link.');
                } else {
                    showStatus('success', 'Transaction confirmed on-chain!');
                }
                
                // 6. Update UI
                status.innerHTML += `<br><a href="https://solscan.io/tx/${sigString}" target="_blank" class="tx-link">View on Solscan: ${sigString}</a> <button class="copy-btn" data-sig="${sigString}" aria-label="Copy transaction signature">Copy</button>`;
                inscribeBtn.textContent = "Inscribe Again";
                inscribeBtn.disabled = false;

            } catch (err) {
                console.error("‚ùå FAILURE:", err);
                showStatus('error', 'Error: ' + err.message);
                inscribeBtn.disabled = false;
                inscribeBtn.textContent = "Try Again";
            }
        });

        // Lookup memo by transaction signature
        lookupBtn.addEventListener('click', async () => {
            const sig = txLookupInput.value.trim();
            if (!sig) {
                lookupStatus.className = 'status error';
                lookupStatus.textContent = 'Please paste a transaction signature.';
                lookupStatus.style.display = 'block';
                return;
            }

            try {
                lookupBtn.disabled = true;
                lookupBtn.textContent = 'Fetching...';
                lookupStatus.style.display = 'none';

                // RPC endpoints (try in order, no API keys required)
                const rpcEndpoints = [
                    'https://solana.drpc.org',
                    'https://solana.lavenderfive.com',
                    'https://public.rpc.solanavibestation.com',
                    'https://solana.leorpc.com/?api_key=FREE',
                    'https://solana.api.onfinality.io/public',
                    'https://solana.api.pocket.network',
                    'https://api.mainnet-beta.solana.com'
                ];
                
                // CORS proxy fallbacks
                const corsProxies = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url='
                ];

                // Helper: try direct, then CORS proxies
                async function tryFetchLookup(endpoint, body) {
                    // Try direct first
                    try {
                        const resp = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(body)
                        });
                        if (resp.ok) {
                            const data = await resp.json();
                            if (data.result) return { data, url: endpoint };
                        }
                    } catch (e) {
                        // Direct failed, try proxies
                    }
                    
                    // Try CORS proxies
                    for (const proxy of corsProxies) {
                        try {
                            const proxyUrl = proxy + encodeURIComponent(endpoint);
                            const resp = await fetch(proxyUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(body)
                            });
                            if (resp.ok) {
                                const data = await resp.json();
                                if (data.result) {
                                    console.log('‚úÖ Lookup via CORS proxy:', proxy);
                                    return { data, url: proxyUrl };
                                }
                            }
                        } catch (e) {
                            // try next proxy
                        }
                    }
                    return null;
                }

                let tx = null;
                let usedRpc = rpcEndpoints[0];
                for (const endpoint of rpcEndpoints) {
                    const result = await tryFetchLookup(endpoint, {
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [sig, { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 }]
                    });
                    
                    if (result?.data?.result) {
                        tx = result.data.result;
                        usedRpc = endpoint;
                        console.log('‚úÖ Lookup connected to:', endpoint);
                        break;
                    }
                }

                if (!tx) {
                    throw new Error('Transaction not found on RPC nodes.');
                }

                // Find memo instruction
                const memoIx = tx.transaction.message.instructions.find(ix => {
                    try {
                        return ix.program === 'spl-memo' || ix.programId === MEMO_PROGRAM_ID || ix.programId?.toString?.() === MEMO_PROGRAM_ID;
                    } catch {
                        return false;
                    }
                });

                if (!memoIx) {
                    throw new Error('No memo instruction found in this transaction.');
                }

                // Try parsed memo first
                let memoText = memoIx.parsed || memoIx.info?.memo;
                if (!memoText) {
                    // Decode data if present
                    const rawData = memoIx.data;
                    if (!rawData) throw new Error('Memo instruction has no data.');
                    try {
                        const decoded = atob(rawData);
                        memoText = new TextDecoder().decode(Uint8Array.from(decoded, c => c.charCodeAt(0)));
                    } catch {
                        // base58 fallback
                        const bytes = decodeBase58(rawData);
                        memoText = new TextDecoder().decode(bytes);
                    }
                }

                lookupStatus.className = 'status success';
                lookupStatus.innerHTML = `RPC: ${usedRpc}<br>Memo: ${memoText}`;
                lookupStatus.style.display = 'block';
            } catch (err) {
                lookupStatus.className = 'status error';
                lookupStatus.textContent = 'Error: ' + err.message;
                lookupStatus.style.display = 'block';
            } finally {
                lookupBtn.disabled = false;
                lookupBtn.textContent = 'Fetch Memo';
            }
        });

        // Auto-connect if already connected
        wallet = getWallet();
        if (wallet && wallet.publicKey) {
            publicKey = wallet.publicKey;
            walletStatus.textContent = 'Connected';
            walletAddress.textContent = `Address: ${publicKey.toString()}`;
            walletAddress.style.display = 'block';
            connectBtn.textContent = 'Disconnect';
            isConnected = true;
            
            // Enable inscribe button if message is valid
            const text = messageInput.value.trim();
            const bytes = new TextEncoder().encode(text).length;
            inscribeBtn.disabled = !text || bytes > MAX_BYTES;
        }
    </script>
</body>
</html>
